I"<h2><img src="http://upload-images.jianshu.io/upload_images/2076247-98a0c6450c69fa62.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="此子必成大器" /></h2>
<blockquote>
  <p>本文介绍内容主要是tableView的性能优化之不使用cornerRadius设置图片圆角</p>
</blockquote>

<p>有人问我为什么tableView滑动不流畅，甚至闪退，其实和cell中的圆角头像使用了cornerRadius有关</p>

<h3 id="优化点">优化点</h3>

<ul>
  <li>行高一定要缓存</li>
  <li>不要动态创建子视图</li>
  <li>所有子视图都要预先创建</li>
  <li>如果不需要显示可以设置hidden</li>
  <li>所有的子视图都应该添加到 <code class="highlighter-rouge">contentView</code>上</li>
  <li>所有的子视图都必须要指定颜色</li>
  <li>不要动态的修改cornerRadius之类的图层渲染相关属性</li>
  <li>使用颜色不要带透明度，此处我们可以使用模拟器中的混合模式去检测，如果如下图所示出现红色，除了UILabel之外，其他的我们都应该尽量去处理</li>
  <li>
    <p>cell栅格化</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>``cell.layer.shouldRasterize = YES;``
  
``cell.layer.rasterizationScale = [UIScreen mainScreen].scale;``
</code></pre></div>    </div>
  </li>
  <li>异步绘制
    <code class="highlighter-rouge">// 异步绘制
    layer.drawsAsynchronously = YES;</code></li>
</ul>

<p><img src="http://upload-images.jianshu.io/upload_images/2076247-b9d269a0daab047f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Color Blended Layers模式下" /></p>

<p>下图是使用了CornerRadius设置圆角之后Color Misaligned Images检测效果
<img src="http://upload-images.jianshu.io/upload_images/2076247-a60b840cceed974b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Color Misaligned Images模式下" /></p>

<p>此处使用了一张800<em>** 800的图片设置在一个200</em>200的ImageView上，没有做任何特殊处理</p>

<hr />

<h3 id="优化步骤">优化步骤</h3>
<ol>
  <li>新建一个UIImage分类</li>
  <li>
    <p>定义方法</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - (void)oa_cornerImageWithSize:(CGSize)size fillColor: (UIColor *)fillColor
    
 completion:(void (^)(UIImage *))completion {
    
 dispatch_async(dispatch_get_global_queue(0, 0), ^{
 NSTimeInterval start = CACurrentMediaTime();
    
 	// 1. 利用绘图，建立上下文
    
 	UIGraphicsBeginImageContextWithOptions(size, YES, 0);
 	CGRect rect = CGRectMake(0, 0, size.width, size.height);
 	// 2. 设置填充颜色
 	[fillColor setFill];
 	UIRectFill(rect);
 	// 3. 利用 贝赛尔路径 `裁切 效果
 	UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:rect];
 	[path addClip];
 	// 4. 绘制图像
 	[self drawInRect:rect];
 	// 5. 取得结果
 	UIImage *result = UIGraphicsGetImageFromCurrentImageContext();
 	// 6. 关闭上下文
 	UIGraphicsEndImageContext();
 	NSLog(@"%f", CACurrentMediaTime() - start);
 	// 7. 完成回调
 	dispatch_async(dispatch_get_main_queue(), ^{
 		if (completion != nil) {
 			completion(result);
 			}
 		});
 	});
 }
</code></pre></div>    </div>
  </li>
</ol>

<p>3.控制器中代码如下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  UIImageView *iv = [[UIImageView alloc]  initWithFrame:CGRectMake(0, 0, 200, 200)];
  iv.center = self.view.center;
  [self.view addSubview:iv];
  // 设置图像
  UIImage *image = [UIImage imageNamed:@"avatar.jpg"];
  [image oa_cornerImageWithSize:iv.bounds.size fillColor:[UIColor whiteColor] completion:^(UIImage *image) {
  iv.image = image;
  }]; 4.模拟器``Color Blended Layers``  和``Color Misaligned Images``检测结果如下图
</code></pre></div></div>

<p><img src="http://upload-images.jianshu.io/upload_images/2076247-d35c6e1664f0601e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优化之后" /></p>

<p>5.Color Misaligned Images 如果是黄色说明图像做过拉伸处理，如果在tableView快速滚动中，附加操作越多，性能越差
使用如上方法不仅可以裁切圆角头像，同时解决了800<em>**800设置在200</em>200的ImageView上会拉伸的问题
此举可以帮助tableView提升一部分性能</p>
:ET