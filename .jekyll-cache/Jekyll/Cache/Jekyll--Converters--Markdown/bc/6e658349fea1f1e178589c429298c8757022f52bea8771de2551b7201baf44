I"8<blockquote>
  <p>参考链接：<a href="https://link.juejin.im/?target=https%3A%2F%2Fgold.xitu.io%2Fentry%2F5796308479bc440066443c8e">losures Capture Semantics, Part 1: Catch them all!</a></p>
</blockquote>

<h2 id="概述">概述</h2>
<p>原文中先定义一个Pokemon类</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Pokemon</span><span class="p">:</span> <span class="kt">CustomDebugStringConvertible</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
  <span class="p">}</span>
  <span class="k">var</span> <span class="nv">debugDescription</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"</span><span class="se">\(</span><span class="n">name</span><span class="se">)</span><span class="s">&gt;"</span> <span class="p">}</span>
  <span class="kd">deinit</span> <span class="p">{</span> <span class="nf">print</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="k">self</span><span class="se">)</span><span class="s"> escaped!"</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>延时执行的闭包</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">delay</span><span class="p">(</span><span class="nv">seconds</span><span class="p">:</span> <span class="kt">Int</span><span class="p">,</span> <span class="nv">closure</span><span class="p">:</span> <span class="p">()</span><span class="o">-&gt;</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">time</span> <span class="o">=</span> <span class="kt">DispatchTime</span><span class="o">.</span><span class="nf">now</span><span class="p">()</span> <span class="o">+</span> <span class="o">.</span><span class="nf">seconds</span><span class="p">(</span><span class="n">seconds</span><span class="p">)</span>
  <span class="kt">DispatchQueue</span><span class="o">.</span><span class="n">main</span><span class="o">.</span><span class="nf">after</span><span class="p">(</span><span class="nv">when</span><span class="p">:</span> <span class="n">time</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"🕑"</span><span class="p">)</span>
    <span class="nf">closure</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="默认捕捉语法">默认捕捉语法</h2>
<p>在swift中默认的捕捉语法是:<strong>被捕获的变量在闭包被执行的时候才被定值</strong><a href="https://link.juejin.im/?target=http%3A%2F%2Falisoftware.github.io%2Fswift%2Fclosures%2F2016%2F07%2F25%2Fclosure-capture-1%2F%23fn%3Ablock-modifier">1</a>
. 我们能说它捕获到了这个变量的<em>引用</em>(或者 <em>指针</em>)。</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">demo1</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">let</span> <span class="nv">pokemon</span> <span class="o">=</span> <span class="kt">Pokemon</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Mewtwo"</span><span class="p">)</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"before closure: </span><span class="se">\(</span><span class="n">pokemon</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
  <span class="nf">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"inside closure: </span><span class="se">\(</span><span class="n">pokemon</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"bye"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这个闭包会在 demo1() 方法函数执行完成后 1 秒后被执行，并且我们已退出了方法函数的作用域… 当然 Pokemon 仍然是存在的，当这个代码块在下一个 1 秒后再次被执行的时候！</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">before</span> <span class="nv">closure</span><span class="p">:</span> <span class="o">&lt;</span><span class="kt">Pokemon</span> <span class="kt">Mewtwo</span><span class="o">&gt;</span>
<span class="n">bye</span>
<span class="n">🕑</span>
<span class="n">inside</span> <span class="nv">closure</span><span class="p">:</span> <span class="o">&lt;</span><span class="kt">Pokemon</span> <span class="kt">Mewtwo</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="kt">Pokemon</span> <span class="kt">Mewtwo</span><span class="o">&gt;</span> <span class="n">escaped</span><span class="o">!</span>
</code></pre></div></div>
<p>在这个例子中，当这个闭包被 GCD 执行后，这个闭包自行释放，就是 Pokemon 内部的 init 方法执行的时候。
此处Swift自动捕获到这个pokemon变量，当demo1方法执行完成并且释放掉的时候，1s之后闭包被执行的时候还是捕获到了pokemon</p>

<h2 id="被捕获到的变量都被执行的时候定值">被捕获到的变量都被执行的时候定值</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">name</span> <span class="o">=</span> <span class="s">"John"</span>

<span class="k">let</span> <span class="nv">test1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">name</span> <span class="o">=</span> <span class="s">"Aby"</span>

<span class="nf">test1</span><span class="p">()</span>
</code></pre></div></div>
<p>此处在创建了test1闭包之后，我们改变了name的值，打印结果是Aby。说明此处Swift捕获到的是name这个变量的引用(指针)</p>

<p>原文中的例子使用了方法，并做了延时，大意在说明，函数被释放之后的延时闭包中，闭包依然捕获了变量的新值，而不是旧值，说明此处它捕获的是变量的引用，而非变量本身的值</p>

<p>这个在值类型中也可行例如Int</p>

<h2 id="修改变量的值">修改变量的值</h2>
<p>如果捕获的值是一个 var并不是一个 let，你还是可以修改这个值 <strong>在闭包内部</strong><a href="https://link.juejin.im/?target=http%3A%2F%2Falisoftware.github.io%2Fswift%2Fclosures%2F2016%2F07%2F25%2Fclosure-capture-1%2F%23fn%3Aobjc_block_modify">2</a></p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">name</span> <span class="o">=</span> <span class="s">"John"</span>

<span class="k">let</span> <span class="nv">test1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Jack"</span>
    <span class="nf">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">name</span> <span class="o">=</span> <span class="s">"Aby"</span>

<span class="nf">test1</span><span class="p">()</span>
</code></pre></div></div>
<p>此处打印结果为Jack，再一次印证，闭包内捕获的是变量name的引用，因为它可以被改变，而不是一个静态的拷贝</p>

<h2 id="捕获一个作为静态copy的变量">捕获一个作为静态copy的变量</h2>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"Hello, playground"</span>
<span class="k">let</span> <span class="nv">show1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="n">strcopy</span> <span class="o">=</span> <span class="n">str</span><span class="p">]</span> <span class="k">in</span> 
<span class="c1">// 在闭包一开始创建的时候捕获变量的值，</span>
<span class="c1">// []内的为捕获列表，一开始捕获值，而非引用。</span>
<span class="c1">// 捕获的为原始变量的副本-&gt;常量，并且只能在闭包内访问</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="s">"这是str-----</span><span class="se">\(</span><span class="n">str</span><span class="se">)\n</span><span class="s">这是strcopy-----</span><span class="se">\(</span><span class="n">strcopy</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">str</span> <span class="o">=</span> <span class="s">"hello"</span>

<span class="nf">show1</span><span class="p">()</span>
</code></pre></div></div>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">这是str</span><span class="o">-----</span><span class="n">hello</span>
<span class="n">这是strcopy</span><span class="o">-----</span><span class="kt">Hello</span><span class="p">,</span> <span class="n">playground</span>
</code></pre></div></div>
<p>如果你想要在闭包<strong>创建</strong>的时候捕获变量的值，而不是仅仅当闭包执行的时候去获取它的定值，你能使用一个<strong>捕获列表</strong>。
<strong>捕获列表</strong>可以被编码在方括号的中间，在闭包开括号的右边（并且在闭包的参数 / 或者有返回值之前）<a href="https://link.juejin.im/?target=http%3A%2F%2Falisoftware.github.io%2Fswift%2Fclosures%2F2016%2F07%2F25%2Fclosure-capture-1%2F%23fn%3Ain-keyword">3</a>
。
为了在闭包创建的时候，捕获变量的值（而不是这个变量本身的引用），你可以使用 [形参 = 实参]</p>

<p>你也可以这样写，不过我觉得不够清晰</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">str</span> <span class="o">=</span> <span class="s">"Hello, playground"</span>
<span class="k">let</span> <span class="nv">show1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="n">str</span><span class="p">]</span> <span class="k">in</span> 
    <span class="nf">print</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这里的捕获列表大概相当于文中的如下代码</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">demo6_equivalent</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">var</span> <span class="nv">pokemon</span> <span class="o">=</span> <span class="kt">Pokemon</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Pikachu"</span><span class="p">)</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"before closure: </span><span class="se">\(</span><span class="n">pokemon</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
  <span class="c1">// here we create an intermediate variable to hold the instance </span>
  <span class="c1">// pointed by the variable at that point in the code:</span>
  <span class="k">let</span> <span class="nv">pokemonCopy</span> <span class="o">=</span> <span class="n">pokemon</span>
  <span class="nf">delay</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">print</span><span class="p">(</span><span class="s">"inside closure: </span><span class="se">\(</span><span class="n">pokemonCopy</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="n">pokemon</span> <span class="o">=</span> <span class="kt">Pokemon</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="s">"Mewtwo"</span><span class="p">)</span>
  <span class="nf">print</span><span class="p">(</span><span class="s">"after closure: </span><span class="se">\(</span><span class="n">pokemon</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这就好像，如果我们创建一个中间变量去指向同一个 pokemon，并且捕获这个变量
事实上，使用这个捕获列表和上面的代码一样… 除了这个 pokemonCopy 的中间变量是闭包的局部变量，并且将只能在闭包内被访问。</p>

<h2 id="总结">总结</h2>
<ul>
  <li>Swift 闭包捕获了一个对外部变量需要在闭包内部使用的一个引用。</li>
  <li>那个引用在闭包<strong>被执行</strong>的时候获得定值。</li>
  <li>作为对这个变量的引用的捕捉（并且不是这个变量自身），你能从闭包内部修改这个变量的值（当然，如果这个变量被声明为 var 并且不是 let）</li>
  <li>相反，你能告诉 Swfit 在闭包创建的时候对这个变量定值 并且把这个值保存在本地的一个静态变量中，而不是捕获变量本身。你可以通过使用捕获列表(中括号)，在括号内表达。</li>
</ul>

<p>注意：因为捕获列表是一个列表你还可以放多个参数，用逗号隔开，像数组一样</p>

<blockquote>
  <p>最后感谢原文作者</p>
</blockquote>
:ET