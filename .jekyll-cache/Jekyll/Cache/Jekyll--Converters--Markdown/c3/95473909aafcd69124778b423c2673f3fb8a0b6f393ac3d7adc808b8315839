I"\<blockquote>
  <p>###摘要
  <em>本文介绍iOS中的事件循环Runloop;</em></p>
</blockquote>

<p><img src="https://zero-space.s3.amazonaws.com/photos/160b464b-e6e1-4942-8856-01ae98f8c088x840.jpg" alt="" /></p>

<h3 id="runloop-是什么">Runloop 是什么</h3>
<ul>
  <li> Runloop是事件接收和分发机制的一个实现。
    <ul>
      <li>Runloop提供了一种异步执行代码的机制，不能并行执行任务。</li>
      <li>在主队列中，Main RunLoop直接配合任务的执行，负责处理UI事件、定时器以及其他内核相关事件。</li>
    </ul>
  </li>
</ul>

<p>###Runloop的主要目的</p>
<ul>
  <li>保证执行程序的线程不会被终止</li>
</ul>

<p>###什么时候使用Runloop</p>
<ul>
  <li>
    <p>当需要和该线程进行交互的时候才会使用Runloop</p>
  </li>
  <li>
    <p>每一个线程都有其对应的RunLoop，但是默认非主线程的RunLoop是没有运行的，需要为RunLoop添加至少一个事件源，然后去run它。</p>
  </li>
  <li>
    <p>一般情况下我们是没有必要去启用线程的RunLoop的，除非你在一个单独的线程中需要长久的检测某个事件。</p>
  </li>
  <li>
    <h2 id="主线程-默认有runloop当自己启动一个线程如果只是用于处理单一的事件则该线程在执行完之后就退出了所以当我们需要让该线程监听某项事务时就得让线程一直不退出runloop就是这么一个循环没有事件的时候一直卡着有事件来临了执行其对应的函数">主线程 默认有Runloop。当自己启动一个线程，如果只是用于处理单一的事件，则该线程在执行完之后就退出了。所以当我们需要让该线程监听某项事务时，就得让线程一直不退出，runloop就是这么一个循环，没有事件的时候，一直卡着，有事件来临了，执行其对应的函数。</h2>
    <blockquote>
      <p><em>Runloop，正如其名所示，是线程进入和被线程用来响应事件以及调用事件处理函数的地方。需要在代码中使用控制语句实现run loop的循环，也就是说，需要代码提供while 或者 for循环来驱动run loop。</em></p>
    </blockquote>
  </li>
</ul>

<p>在这个循环中使用一个Runloop对象<code class="highlighter-rouge">[NSRunloop currentRunloop]</code>执行接收消息，调用对应的处理函数。</p>
<ul>
  <li>
    <p>Runloop接收两种源事件:<code class="highlighter-rouge">input sources</code>和<code class="highlighter-rouge">timer sources</code>。</p>
  </li>
  <li>
    <p>input sources 传递异步事件，通常是来自其他线程和不同的程序中的消息；</p>
  </li>
  <li>
    <p> timer sources(定时器) 传递同步事件（重复执行或者在特定时间上触发）。</p>
  </li>
  <li>
    <p>除了处理<code class="highlighter-rouge">input sources</code>，Runloop 也会产生一些关于本身行为的<code class="highlighter-rouge">notificaiton</code>。注册成为Runloop的<code class="highlighter-rouge">observer</code>，可以接收到这些notification，做一些额外的处理。（使用<code class="highlighter-rouge">CoreFoundation</code>来成为runloop的observer）。</p>
  </li>
</ul>

<p>###Runloop特性</p>

<ul>
  <li>
    <p>当有事件发生时，Runloop会根据具体的事件类型通知应用程序作出响应；</p>
  </li>
  <li>
    <p>当没有事件发生时，Runloop会进入休眠状态，从而达到省电的目的；</p>
  </li>
  <li>
    <p>当事件再次发生时，Runloop会被重新唤醒，处理事件。</p>
  </li>
  <li>iOS 中所有的事件监听全部由运行循环负责</li>
  <li>主线程的 RunLoop在应用启动的时候就会自动创建</li>
  <li>其他线程则需要在该线程下自己启动</li>
  <li>不能自己创建 RunLoop</li>
  <li>RunLoop 并不是线程安全的，所以需要避免在其他线程上调用当前线程的 RunLoop</li>
  <li>RunLoop 负责管理 <code class="highlighter-rouge">autorelease pools</code></li>
  <li>RunLoop 负责处理消息事件，即输入源事件、计时器事件和网络请求事情</li>
</ul>

<p>###应用场景</p>
<ul>
  <li>
    <p>创建常驻线程，执行一些会一直存在的任务。该线程的生命周期跟 App
 相同
    @autoreleasepool { 
       NSLog(@”%@”, [NSThread currentThread]); 
       NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; 
       // 只有添加端口后，才能能够保证运行循环持续运行 
       [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; 
       [runLoop run];</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   // 线程结束之前，不会执行至此 
   NSLog(@"%@", [NSThread currentThread]);
}
</code></pre></div>    </div>
  </li>
  <li>维护线程的生命周期，让线程不自动退出，<code class="highlighter-rouge">isFinished</code>
 为 <code class="highlighter-rouge">Yes</code>时退出</li>
  <li>
    <h2 id="在一定时间内监听某种事件或执行某种任务的线程">在一定时间内监听某种事件，或执行某种任务的线程</h2>
    <blockquote>
      <p>####提示：一般在开发中很少会主动创建Runloop，而通常会把事件添加到Runloop中。</p>
    </blockquote>
  </li>
</ul>

<p>###参考文章
<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23">官方文档</a> 
<a href="http://blog.ibireme.com/2015/05/18/runloop/">深入理解Runloop</a>
<a href="http://www.cnblogs.com/zy1987/p/4582466.html">Runloop原理和核心机制</a></p>
:ET